<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Teoria</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="common.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Noto%20Serif"
  />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=JetBrains+Mono"
  />
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script defer src="benchmark.js"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<nav>
  <a href="/index.html">home</a>
  <a href="/teoria.html">teoria</a>
  <a href="/manuale.html">manuale</a>
  <a href="/applicazione.html">applicazione</a>
</nav>
<h1 id="indice">Indice <!-- omit in toc --></h1>
<ul>
<li><a href="#involucro-convesso">Involucro convesso</a>
<ul>
<li><a href="#rappresentare-h">Rappresentare H</a></li>
<li><a href="#assunzioni-sullinsieme-di-punti">Assunzioni sull’insieme
di punti</a></li>
<li><a
href="#lower-bound-della-complessità-del-problema-in-dipendenza-da-n">Lower
bound della complessità del problema (in dipendenza da n)</a>
<ul>
<li><a href="#dimostrazione">Dimostrazione</a></li>
</ul></li>
</ul></li>
<li><a href="#involucri-clockwise-e-counterclockwise">Involucri
clockwise e counterclockwise</a>
<ul>
<li><a href="#spiegazione">Spiegazione</a></li>
</ul></li>
<li><a href="#algoritmo-naive">Algoritmo Naive</a>
<ul>
<li><a href="#idea">Idea</a></li>
<li><a href="#half-plane-test">Half-plane test</a></li>
<li><a href="#come-trovare-un-vettore-perpendicolare-ad-un-altro">Come
trovare un vettore perpendicolare ad un altro?</a></li>
<li><a href="#complessità-temporale">Complessità temporale</a></li>
</ul></li>
<li><a href="#algoritmo-divide-and-conquer">Algoritmo Divide and
Conquer</a>
<ul>
<li><a href="#idea-1">Idea</a></li>
<li><a href="#fusione">Fusione</a></li>
<li><a href="#ricerca-tangente-superiore">Ricerca tangente
superiore</a></li>
<li><a href="#ricerca-tangente-inferiore">Ricerca tangente
inferiore</a></li>
<li><a href="#costruzione-di-h">Costruzione di H</a></li>
<li><a href="#complessità-temporale-1">Complessità temporale</a>
<ul>
<li><a href="#ricerca-delle-tangenti">Ricerca delle tangenti</a></li>
<li><a href="#fusione-1">Fusione</a></li>
<li><a href="#divide-and-conquer">Divide and Conquer</a></li>
<li><a href="#complessità-complessiva">Complessità complessiva</a></li>
</ul></li>
</ul></li>
<li><a href="#algoritmo-di-akl-toussaint">Algoritmo di Akl-Toussaint</a>
<ul>
<li><a href="#idea-2">Idea</a>
<ul>
<li><a href="#euristica">Euristica</a></li>
<li><a
href="#ricerca-dei-percorsi-convessi-per-ogni-lato-del-quadrilatero">Ricerca
dei percorsi convessi per ogni lato del quadrilatero</a></li>
<li><a href="#costruzione-dellinvolucro-convesso-h">Costruzione
dell’involucro convesso H</a></li>
</ul></li>
<li><a
href="#ricerca-di-un-percorso-convesso-di-una-data-regione">Ricerca di
un percorso convesso di una data regione</a></li>
<li><a href="#complessità-temporale-2">Complessità temporale</a>
<ul>
<li><a href="#euristica-1">Euristica</a></li>
<li><a href="#ricerca-del-percorso-convesso">Ricerca del percorso
convesso</a></li>
<li><a href="#costruzione-di-h-1">Costruzione di H</a></li>
<li><a href="#complessità-complessiva-1">Complessità
complessiva</a></li>
</ul></li>
</ul></li>
<li><a href="#torch-total-order-heuristic-based-convex-hull">TORCH:
Total Order Heuristic Based Convex Hull</a>
<ul>
<li><a href="#idea-3">Idea</a></li>
<li><a href="#ordinamento-di-s">Ordinamento di S</a></li>
<li><a href="#costruzione-di-h-2">Costruzione di H’</a>
<ul>
<li><a href="#costruzione-dellinvolucro-laterale-nw">Costruzione
dell’involucro laterale NW</a></li>
<li><a href="#costruzione-dellinvolucro-laterale-ne">Costruzione
dell’involucro laterale NE</a></li>
<li><a href="#costruzione-dellinvolucro-laterale-sw">Costruzione
dell’involucro laterale SW</a></li>
<li><a href="#costruzione-dellinvolucro-laterale-se">Costruzione
dell’involucro laterale SE</a></li>
<li><a href="#concatenazione-degli-involucri-laterali">Concatenazione
degli involucri laterali</a></li>
<li><a href="#convessificazione-di-h">Convessificazione di H’</a></li>
<li><a href="#complessità-temporale-3">Complessità temporale</a></li>
</ul></li>
</ul></li>
<li><a
href="#benchmark-degli-algoritmi-per-il-calcolo-dellinvolucro-convesso">Benchmark
degli algoritmi per il calcolo dell’involucro convesso</a></li>
<li><a
href="#algoritmo-di-approssimazione-di-bentley-faust-e-preparata">Algoritmo
di approssimazione di Bentley, Faust e Preparata</a>
<ul>
<li><a href="#idea-4">Idea</a>
<ul>
<li><a href="#complessità-temporale-4">Complessità temporale</a></li>
</ul></li>
<li><a href="#determinazione-di-s">Determinazione di S’</a>
<ul>
<li><a href="#proprietà">Proprietà</a>
<ul>
<li><a href="#dimostrazione-1">Dimostrazione</a></li>
</ul></li>
<li><a href="#proprietà-1">Proprietà</a>
<ul>
<li><a href="#dimostrazione-2">Dimostrazione</a></li>
</ul></li>
<li><a href="#corollario">Corollario</a>
<ul>
<li><a href="#dimostrazione-3">Dimostrazione</a></li>
</ul></li>
<li><a href="#complessità-temporale-5">Complessità temporale</a></li>
</ul></li>
</ul></li>
</ul>
<h1 id="involucro-convesso">Involucro convesso</h1>
<p><img src="./convex_hull_io.svg"
style="height: 190px; display: block; margin: auto;" /></p>
<p><strong>Input</strong>: Insieme finito <span class="math inline">\(S
\subseteq \mathbb{R}^2\)</span>.</p>
<p><strong>Output</strong>: Poligono convesso <span
class="math inline">\(H\)</span> di area minima che contiene tutti i
punti di <span class="math inline">\(S\)</span>.</p>
<p>Denotiamo con:</p>
<ul>
<li><span class="math inline">\(P(H)\)</span> l’insieme di vertici di
<span class="math inline">\(H\)</span>.</li>
<li><span class="math inline">\(d\)</span> la cardinalità di <span
class="math inline">\(P(H)\)</span>.</li>
<li><span class="math inline">\(n\)</span> la cardinalità di <span
class="math inline">\(S\)</span>.</li>
</ul>
<p><strong>Proprietà</strong>: <span class="math inline">\(P(H)
\subseteq S\)</span>.</p>
<p><strong>Corollario</strong>: <span class="math inline">\(d \le
n\)</span></p>
<h2 id="rappresentare-h">Rappresentare H</h2>
<p>Rappresentiamo <span class="math inline">\(H\)</span> usando una
lista ordinata di punti di <span
class="math inline">\(P(H)\)</span>:</p>
<p><span class="math display">\[P_1, P_2, P_3, ..., P_d \qquad P_i \in
P(H), i = 1, ..., d\]</span></p>
<p>Tale che:</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., d - 1\)</span> il
segmento di estremi <span class="math inline">\(P_i\)</span> e <span
class="math inline">\(P_{i+1}\)</span> è un lato di <span
class="math inline">\(H\)</span>.</li>
<li>Il segmento di estremi <span class="math inline">\(P_d\)</span> e
<span class="math inline">\(P_1\)</span> è un lato di <span
class="math inline">\(H\)</span>.</li>
</ul>
<h2 id="assunzioni-sullinsieme-di-punti">Assunzioni sull’insieme di
punti</h2>
<p>Nella nostra trattazione assumiamo che l’insieme di punti <span
class="math inline">\(S\)</span> soddisfi le seguenti condizioni:</p>
<ol type="1">
<li><p><strong>Non collinearità.</strong> Non esistono tre punti di
<span class="math inline">\(S\)</span> che giacciono sulla stessa
retta.</p></li>
<li><p><strong>Distanza minima.</strong> Per ogni coppia di punti <span
class="math inline">\(a,b\in S\)</span>, imponiamo <span
class="math display">\[\Delta X \ge 1 \quad \textrm{e} \quad \Delta Y
\ge 1\]</span> dove <span class="math display">\[\Delta X = |a_x - b_x|
\quad \textrm{e} \quad \Delta Y = |a_y - b_y|\]</span> In tal modo due
punti non possono trovarsi “troppo” vicini tra loro.</p></li>
</ol>
<h2
id="lower-bound-della-complessità-del-problema-in-dipendenza-da-n">Lower
bound della complessità del problema (in dipendenza da n)</h2>
<p>Il lower bound del problema è <span class="math inline">\(\Omega(n
\hspace{0.25em}log \hspace{0.25em}n)\)</span>.</p>
<h3 id="dimostrazione">Dimostrazione</h3>
<p><img src="./lower_bound.svg"
style="height: 300px; display: block; margin: auto;" /></p>
<p>Supponiamo di avere il seguente insieme finito di numeri</p>
<p><span class="math display">\[I = \{ x_1, x_2, x_3, ..., x_n \}
\subseteq \mathbb{R} \quad \textrm{dove} \quad x_1 &lt; x_2 &lt; x_3
&lt; ... &lt; x_n\]</span></p>
<p>Definiamo il seguente insieme</p>
<p><span class="math display">\[S = \{ (x_i, x_i^2) \mid x_i \in I \}
\subseteq \mathbb{R}^2\]</span></p>
<p>Notiamo come i punti di <span class="math inline">\(S\)</span>
giacciono su una parabola. Proprio per questo, è facile vedere che un
possibile involucro convesso di <span class="math inline">\(S\)</span> è
dato dalla lista <span class="math inline">\((x_1, x_1^2), (x_2, x_2^2),
..., (x_n, x_n^2)\)</span>.</p>
<p>Se ottenessimo una qualsiasi altra lista, potremmo ottenere quella
mostrata sopra in tempo <span class="math inline">\(O(d)\)</span> e
dunque <span class="math inline">\(O(n)\)</span>, trattandosi di una
ricerca dell’elemento minimo.</p>
<p>Supponiamo ora, per assurdo, di essere in grado di trovare
l’involucro convesso di <span class="math inline">\(S\)</span> in tempo
inferiore a <span class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<p>Se questo fosse il caso, prendendo la prima proiezione della lista
<span class="math inline">\((x_1, x_1^2), (x_2, x_2^2), ..., (x_n,
x_n^2)\)</span>. otterremo la lista <span class="math inline">\(x_1,
x_2, ..., x_n\)</span>. Dunque saremmo in grado di ordinare l’insieme
<span class="math inline">\(I\)</span> in tempo inferiore a <span
class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<p>Questo è assurdo perché il lower bound del problema dell’ordinamento
è <span class="math inline">\(\Omega(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>. <span
class="math inline">\(\square\)</span></p>
<h1 id="involucri-clockwise-e-counterclockwise">Involucri clockwise e
counterclockwise</h1>
<p>Come abbiamo già detto, rappresentiamo l’involucro convesso <span
class="math inline">\(H\)</span> usando una lista dei punti di <span
class="math inline">\(P(H)\)</span>.</p>
<p>Consideriamo il seguente involucro convesso <span
class="math inline">\(H\)</span>:</p>
<p><img src="./involucro_triangolare.svg"
style="height: 170px; display: block; margin: auto;" /></p>
<p>Possiamo rappresentare <span class="math inline">\(H\)</span> usando
entrambe queste liste:</p>
<p><span class="math display">\[A, B, C \quad \textrm{e} \quad A, C,
B\]</span></p>
<p>Osserviamo come la prima lista elenca i punti di <span
class="math inline">\(H\)</span> in senso antiorario. La seconda lista
invece elenca i punti in senso orario <a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>Nella nostra trattazione, per convenzione e per facilitare
l’implementazione degli algoritmi, useremo e otterremo sempre liste che
elencano i punti dell’involucro convesso in senso orario.</p>
<p>Può accadere di dover controllare se un involucro convesso è espresso
in senso orario o antiorario. Per fare questo:</p>
<ul>
<li><p>Prendiamo tre punti qualsiasi di <span
class="math inline">\(H\)</span> <span class="math inline">\(\vec{u},
\vec{v}, \vec{w}\)</span> <strong>consecutivi</strong>.</p></li>
<li><p>Consideriamo i due vettori <span class="math inline">\(\vec{v} -
\vec{u} \hspace{0.5em}\textrm{e} \hspace{0.5em}\vec{w} -
\vec{v}\)</span>.</p>
<ul>
<li><p>Se <span class="math inline">\(det \begin{pmatrix} \vec{v}_x -
\vec{u}_x &amp; \vec{w}_x - \vec{v}_x \\ \vec{v_y} - \vec{u_y} &amp;
\vec{w_y} - \vec{v_y} \end{pmatrix} &gt; 0\)</span>, allora siamo in
senso antiorario.</p></li>
<li><p>Se <span class="math inline">\(det\begin{pmatrix} \vec{v}_x -
\vec{u}_x &amp; \vec{w}_x - \vec{v}_x \\ \vec{v_y} - \vec{u_y} &amp;
\vec{w_y} - \vec{v_y} \end{pmatrix} &lt; 0\)</span>, allora siamo in
senso orario.</p></li>
<li><p>Se il determinante è uguale a zero allora i tre punti sono
collineari. Ricordiamo che, per costruzione, <span
class="math inline">\(S\)</span> non contiene terne di punti
collineari.</p></li>
</ul></li>
</ul>
<p>Se l’involucro è espresso in un senso, per esprimerlo nell’altro
bisogna semplicemente invertire l’ordine della lista.</p>
<h2 id="spiegazione">Spiegazione</h2>
<p>Possiamo osservare che</p>
<p><span class="math display">\[
\begin{aligned}
\det\begin{pmatrix}
\vec{v}_x - \vec{u}_x &amp; \vec{w}_x - \vec{v}_x \\
\vec{v}_y - \vec{u}_y &amp; \vec{w}_y - \vec{v}_y
\end{pmatrix}
&amp;= (\vec{v}_x - \vec{u}_x)(\vec{w}_y - \vec{v}_y) - (\vec{v}_y -
\vec{u}_y)(\vec{w}_x - \vec{v}_x) &amp;&amp; \textrm{Definizione di
determinante} \\[8pt]
&amp;= (\vec{v}_x - \vec{u}_x)(\vec{w}_y - \vec{v}_y) + (-(\vec{v}_y -
\vec{u}_y))(\vec{w}_x - \vec{v}_x) &amp;&amp; \textrm{Portiamo dentro il
&quot;-&quot;} \\[8pt]
&amp;=
\begin{bmatrix}
-(\vec{v}_y - \vec{u}_y) \\
\vec{v}_x - \vec{u}_x
\end{bmatrix}
\cdot
\begin{bmatrix}
\vec{w}_x - \vec{v}_x \\
\vec{w}_y - \vec{v}_y
\end{bmatrix} &amp;&amp; \textrm{Definizione del dot product} \\[8pt]
&amp;=
\left\lVert
\begin{bmatrix}
-(\vec{v}_y - \vec{u}_y) \\
\vec{v}_x - \vec{u}_x
\end{bmatrix}
\right\rVert
\hspace{0.5em}
\left\lVert
\begin{bmatrix}
\vec{w}_x - \vec{v}_x \\
\vec{w}_y - \vec{v}_y
\end{bmatrix}
\right\rVert
\hspace{0.5em}
\cos\theta
&amp;&amp; \textrm{Definizione del dot product}
\end{aligned}
\]</span></p>
<p>con <span class="math inline">\(\theta\)</span> angolo tra <span
class="math inline">\(\begin{bmatrix} -(\vec{v}_y - \vec{u}_y) \\
\vec{v}_x - \vec{u}_x \end{bmatrix} \quad \text{e} \quad \begin{bmatrix}
\vec{w}_x - \vec{v}_x \\ \vec{w}_y - \vec{v}_y
\end{bmatrix}\)</span>.</p>
<p>Notiamo come <span class="math inline">\(\begin{bmatrix} -(\vec{v}_y
- \vec{u}_y) \\ \vec{v}_x - \vec{u}_x \end{bmatrix}\)</span> è
perpendicolare a <span class="math inline">\(\begin{bmatrix} \vec{v}_x -
\vec{u}_x \\ \vec{v}_y - \vec{u}_y \end{bmatrix}\)</span> e lo denotiamo
con <span class="math inline">\((\vec{v} - \vec{u})_\perp\)</span>.</p>
<p>Vediamo “in azione” il test sull’involucro mostrato sopra, sia per il
caso orario che antiorario.</p>
<p><img src="./ccw_test.svg"
style="height: 200px; display: block; margin: auto;" /></p>
<p><img src="./cw_test.svg"
style="height: 300px; display: block; margin: auto;" /></p>
<aside id="footnotes" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol>
<li id="fn1"><p>Non vi sono altre orientazioni possibili.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 id="algoritmo-naive">Algoritmo Naive</h1>
<h2 id="idea">Idea</h2>
<p>Per ogni coppia di punti <span class="math inline">\(\vec{u}, \vec{v}
\in S\)</span>, con <span class="math inline">\(\vec{u} \neq
\vec{v}\)</span>:</p>
<p>Consideriamo la retta <span class="math inline">\(r\)</span> passante
per <span class="math inline">\(\vec{u}\)</span> e <span
class="math inline">\(\vec{v}\)</span>.</p>
<p>Questa divide il piano <span class="math inline">\(\Pi\)</span> in
due semipiani, <span class="math inline">\(\Pi^+
\hspace{0.5em}\textrm{e} \hspace{0.5em}\Pi^-\)</span>.</p>
<p>Per ogni punto <span class="math inline">\(\vec{p} \in S\)</span> con
<span class="math inline">\(\vec{p} \neq \vec{u}
\hspace{0.5em}\textrm{e} \hspace{0.5em}\vec{p} \neq \vec{v}\)</span>
controlliamo se <span class="math inline">\(\vec{p}\)</span> cade in
<span class="math inline">\(\Pi^+ \hspace{0.5em}\textrm{o}
\hspace{0.5em}\textrm{in} \hspace{0.5em}\Pi^-\)</span>.</p>
<p>Se tutti i punti sono caduti esclusivamente in uno dei due semipiani,
allora il segmento con estremi <span class="math inline">\(\vec{u}
\hspace{0.5em}\textrm{e} \hspace{0.5em}\vec{v} \hspace{0.25em}\)</span>
è un lato dell’involucro convesso.</p>
<h2 id="half-plane-test">Half-plane test</h2>
<p><img src="./half_plane_test.svg"
style="height: 300px; display: block; margin: auto;" /></p>
<p>Come possiamo controllare se un punto <span
class="math inline">\(\vec{p}\)</span> cade in <span
class="math inline">\(\Pi^+ \hspace{0.5em}\textrm{o}
\hspace{0.5em}\Pi^-\)</span>?</p>
<p>Supponiamo che il vettore <span class="math inline">\(\vec{v} -
\vec{u}\)</span> è un possibile vettore direzione della retta <span
class="math inline">\(r\)</span>.</p>
<p>Dato il vettore <span class="math inline">\(\vec{v} -
\vec{u}\)</span> troviamo un vettore <span
class="math inline">\(\vec{n}\)</span> perpendicolare ad esso.</p>
<p><span class="math inline">\(\vec{n}\)</span> è una possibile normale
della retta <span class="math inline">\(r\)</span>.</p>
<p>Dato un qualsiasi punto <span
class="math inline">\(\vec{p}\)</span>:</p>
<ol type="1">
<li>Prendiamo il vettore <span class="math inline">\(\vec{p} -
\vec{u}\)</span>.</li>
<li>Se <span class="math inline">\(\vec{n} \cdot (\vec{p} - \vec{u})
&gt; 0\)</span>, allora siamo in <span
class="math inline">\(\Pi^+\)</span>. <br /> Se <span
class="math inline">\(\vec{n} \cdot (\vec{p} - \vec{u}) &lt; 0\)</span>,
allora siamo in <span class="math inline">\(\Pi^-\)</span>.</li>
</ol>
<p>Nell’immagine d’esempio <span class="math inline">\(\vec{n} \cdot
(\vec{p} - \vec{u})\)</span> è positivo perché <span
class="math inline">\(0 &lt; \theta &lt; \dfrac{\pi}{2}
\hspace{0.5em}\textrm{invece} \hspace{0.5em}\vec{n} \cdot (\vec{q} -
\vec{u})\)</span> è negativo perché <span
class="math inline">\(\dfrac{\pi}{2} &lt; \phi &lt; \pi\)</span>.</p>
<h2 id="come-trovare-un-vettore-perpendicolare-ad-un-altro">Come trovare
un vettore perpendicolare ad un altro?</h2>
<p><img src="./vettori_perpendicolari.svg"
style="height: 250px; display: block; margin: auto;" /></p>
<p>Consideriamo il vettore <span class="math inline">\(\vec{v}
\leftrightarrow \begin{bmatrix} v_x \\ v_y \end{bmatrix}\)</span>.</p>
<p>Un vettore <span class="math inline">\(\vec{u} \leftrightarrow
\begin{bmatrix} u_x \\ u_y \end{bmatrix}\)</span> è perpendicolare a
<span class="math inline">\(\vec{v}\)</span> se e solo se <span
class="math inline">\(\vec{u} \cdot \vec{v} = 0\)</span>.</p>
<p>Vogliamo determinare <span class="math inline">\(u_x
\hspace{0.5em}\textrm{e} \hspace{0.5em}u_y\)</span>, essendo a
conoscenza di <span class="math inline">\(v_x \hspace{0.5em}\textrm{e}
\hspace{0.5em}v_y\)</span>.</p>
<p>Sappiamo che <span class="math inline">\(\vec{u} \cdot \vec{v} =
0\)</span> se e solo se <span class="math inline">\(u_x v_x + u_y v_y =
0\)</span>.</p>
<p>Dunque <span class="math inline">\(u_x = - \dfrac{u_y
v_y}{v_x}\)</span></p>
<p>Fissando <span class="math inline">\(u_y = v_x\)</span>, abbiamo che
<span class="math inline">\(u_x = - \dfrac{v_x v_y}{v_x} =
-v_y\)</span>.</p>
<h2 id="complessità-temporale">Complessità temporale</h2>
<ul>
<li>Iterare per ogni coppia di punti <span
class="math inline">\(\rightarrow O(n^2)\)</span>.
<ul>
<li>Iterare per ogni punto <span class="math inline">\(\rightarrow
O(n)\)</span>.</li>
</ul></li>
<li>Combinando le due iterazioni, vediamo come la complessità temporale
dell’algoritmo è <span class="math inline">\(O(n^3)\)</span>.</li>
</ul>
<h1 id="algoritmo-divide-and-conquer">Algoritmo Divide and Conquer</h1>
<h2 id="idea-1">Idea</h2>
<p><img src="./dc_tangents.svg"
style="height: 250px; display: block; margin: auto;" /></p>
<p>Sia <span class="math inline">\(P\)</span> la lista dei punti di
<span class="math inline">\(S\)</span>, ordinata in ordine crescente
rispetto alla loro componente <span
class="math inline">\(x\)</span>.</p>
<p>Dividiamo <span class="math inline">\(P\)</span> a metà, ottenendo
così le liste <span class="math inline">\(A\)</span> e <span
class="math inline">\(B\)</span>.</p>
<p>Applichiamo ricorsivamente l’algoritmo Divide and Conquer su <span
class="math inline">\(A\)</span> e su <span
class="math inline">\(B\)</span>, ottenendo così gli involucri convessi
<span class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span> rispettivamente, degli insiemi di
punti dati dalle liste <span class="math inline">\(A\)</span> e <span
class="math inline">\(B\)</span>.</p>
<p>Fondiamo <span class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span>, ottenendo così l’involucro <span
class="math inline">\(H\)</span>.</p>
<h2 id="fusione">Fusione</h2>
<p>Dati due involucri convessi <span class="math inline">\(H_a\)</span>
e <span class="math inline">\(H_b\)</span>, vogliamo trovare l’involucro
convesso <span class="math inline">\(H\)</span> dell’unione dei vertici
di <span class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span>.</p>
<p>Possiamo fare questo sfruttando il fatto che:</p>
<ul>
<li><span class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span> sono involucri convessi.</li>
<li><span class="math inline">\(H_a\)</span> è alla sinistra di <span
class="math inline">\(H_b\)</span>.</li>
</ul>
<p>Per quanto detto sopra, è facile vedere che l’involucro convesso
<span class="math inline">\(H\)</span> risultato dalla fusione di <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span> è composto da:</p>
<ul>
<li>Una porzione dell’involucro di <span
class="math inline">\(H_a\)</span>.</li>
<li>Una porzione dell’involucro di <span
class="math inline">\(H_b\)</span>.</li>
<li>Due segmenti, dette tangenti, ognuna con estremi sia un vertice di
<span class="math inline">\(H_a\)</span> che un vertice di <span
class="math inline">\(H_b\)</span>.</li>
</ul>
<p>La procedura di fusione si riduce dunque alla ricerca di queste due
tangenti, una detta tangente superiore, e l’altra detta tangente
inferiore. Per trovarle utilizzeremo il cosiddetto “two fingers
method”.</p>
<h2 id="ricerca-tangente-superiore">Ricerca tangente superiore</h2>
<p>Sia <span class="math inline">\(r_a\)</span> il punto più a destra di
<span class="math inline">\(H_a\)</span>.</p>
<p>Sia <span class="math inline">\(l_b\)</span> il punto più a sinistra
di <span class="math inline">\(H_b\)</span>.</p>
<p>Consideriamo la retta <span class="math inline">\(r: x = m,
\hspace{0.5em}\textrm{dove} \hspace{0.5em}m = \dfrac{(r_a)_x +
(l_b)_x}{2}\)</span></p>
<p>Percorriamo simultaneamente, in modo alternato:</p>
<ul>
<li><span class="math inline">\(H_a\)</span> in senso
<strong>antiorario</strong>, partendo da <span
class="math inline">\(r_a\)</span>.</li>
<li><span class="math inline">\(H_b\)</span> in senso
<strong>orario</strong>, partendo da <span
class="math inline">\(l_b\)</span>.</li>
</ul>
<p>Cercando il segmento di estremi <span
class="math inline">\(p\)</span> e <span
class="math inline">\(q\)</span>, con <span
class="math inline">\(p\)</span> vertice di <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(q\)</span> vertice di <span
class="math inline">\(H_b\)</span>, tale per cui la sua intersezione con
<span class="math inline">\(r\)</span> abbia componente <span
class="math inline">\(y\)</span> massima.</p>
<p>Il segmento <span class="math inline">\(pq\)</span> è la tangente
superiore.</p>
<h2 id="ricerca-tangente-inferiore">Ricerca tangente inferiore</h2>
<p>Sia <span class="math inline">\(r_a\)</span> il punto più a destra di
<span class="math inline">\(H_a\)</span>.</p>
<p>Sia <span class="math inline">\(l_b\)</span> il punto più a sinistra
di <span class="math inline">\(H_b\)</span>.</p>
<p>Consideriamo la retta <span class="math inline">\(r: x = m,
\hspace{0.5em}\textrm{dove} \hspace{0.5em}m = \dfrac{(r_a)_x +
(l_b)_x}{2}\)</span></p>
<p>Percorriamo simultaneamente, in modo alternato:</p>
<ul>
<li><span class="math inline">\(H_a\)</span> in senso
<strong>orario</strong>, partendo da <span
class="math inline">\(r_a\)</span>.</li>
<li><span class="math inline">\(H_b\)</span> in senso
<strong>antiorario</strong>, partendo da <span
class="math inline">\(l_b\)</span>.</li>
</ul>
<p>Cercando il segmento di estremi <span
class="math inline">\(p\)</span> e <span
class="math inline">\(q\)</span>, con <span
class="math inline">\(p\)</span> vertice di <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(q\)</span> vertice di <span
class="math inline">\(H_b\)</span>, tale per cui la sua intersezione con
<span class="math inline">\(r\)</span> abbia componente <span
class="math inline">\(y\)</span> minima.</p>
<p>Il segmento <span class="math inline">\(pq\)</span> è la tangente
inferiore.</p>
<h2 id="costruzione-di-h">Costruzione di H</h2>
<p>Per costruire <span class="math inline">\(H\)</span>,
percorriamo:</p>
<ul>
<li><p><span class="math inline">\(H_a\)</span>, partendo dal vertice
appartenente alla tangente inferiore fino al vertice appartenente alla
tangente superiore, procedendo in senso orario.</p></li>
<li><p><span class="math inline">\(H_b\)</span>, partendo dal vertice
appartenente alla tangente superiore fino al vertice appartenente alla
tangente inferiore, procedendo in senso orario.</p></li>
</ul>
<h2 id="complessità-temporale-1">Complessità temporale</h2>
<h3 id="ricerca-delle-tangenti">Ricerca delle tangenti</h3>
<p>Usando un approccio naive, possiamo cercare una tangente andando ad
esaminare tutte le coppie di punti <span class="math inline">\((p, q)
\in P(H_a) \times P(H_b)\)</span> ed usare il two fingers method per
trovare la tangente cercata.</p>
<p>Siccome <span class="math inline">\(\left| P(H_a) \right|
\hspace{0.5em}\textrm{e} \hspace{0.5em}\left| P(H_b) \right|\)</span>
sono di complessità <span class="math inline">\(O(n)\)</span>, questo
metodo naive richiederebbe un tempo <span
class="math inline">\(O(n^2)\)</span>.</p>
<p>Tuttavia possiamo fare di meglio se sfruttiamo il fatto che sia <span
class="math inline">\(H_a\)</span> che <span
class="math inline">\(H_b\)</span> sono poligoni convessi.</p>
<p>Percorriamo simultaneamente, in modo alternato, <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span>. Ad ogni iterazione, confrontiamo tre
segmenti:</p>
<ol type="1">
<li>Il segmento tra il vertice corrente di <span
class="math inline">\(H_a\)</span> e il vertice corrente di <span
class="math inline">\(H_b\)</span>.</li>
<li>Il segmento tra il vertice corrente di <span
class="math inline">\(H_a\)</span> e il vertice successivo di <span
class="math inline">\(H_b\)</span>.</li>
<li>Il segmento tra il vertice successivo di <span
class="math inline">\(H_a\)</span> e il vertice corrente di <span
class="math inline">\(H_b\)</span>.</li>
</ol>
<p>Se 2. è “migliore” di 1., allora avanziamo il vertice corrente di
<span class="math inline">\(H_b\)</span>. Se 3. è migliore di 1., allora
avanziamo il vertice corrente di <span
class="math inline">\(H_a\)</span>. Altrimenti terminiamo la visita.</p>
<p>Guardando come visitiamo i vertici di <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span>, vediamo che:</p>
<ul>
<li>Ad ogni iterazione, consideriamo sempre un nuovo vertice.</li>
<li>Passiamo all’iterazione successiva solo se abbiamo trovato un
miglior candidato come tangente.</li>
</ul>
<p>Dunque, per trovare la tangente, ogni vertice di <span
class="math inline">\(H_a\)</span> e <span
class="math inline">\(H_b\)</span> sarà visitato al più un volta.</p>
<p>Dunque, la complessità temporale della ricerca di una tangente è
<span class="math inline">\(O(n)\)</span>.</p>
<h3 id="fusione-1">Fusione</h3>
<p>Il processo di fusione consiste in:</p>
<ol type="1">
<li>Cercare la tangente superiore <span
class="math inline">\(\rightarrow O(n)\)</span></li>
<li>Cercare la tangente inferiore <span
class="math inline">\(\rightarrow O(n)\)</span></li>
<li>Costruire H <span class="math inline">\(\rightarrow
O(n)\)</span></li>
</ol>
<p>Perciò, il processo di fusione ha complessità temporale <span
class="math inline">\(O(n)\)</span>.</p>
<h3 id="divide-and-conquer">Divide and Conquer</h3>
<p>Possiamo vedere che:</p>
<ul>
<li>Ordinamento dei punti in input <span
class="math inline">\(\rightarrow O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.
<ul>
<li>È necessario fare questo ordinamento una volta sola.</li>
</ul></li>
<li>Applichiamo Divide and Conquer ricorsivamente sulle due metà
dell’input <span class="math inline">\(\rightarrow
2T(\dfrac{n}{2})\)</span>.
<ul>
<li><span class="math inline">\(T(n)\)</span> è la funzione che
caratterizza la complessità temporale della parte ricorsiva
dell’algoritmo.</li>
</ul></li>
<li>Fusione <span class="math inline">\(\rightarrow O(n)\)</span>.</li>
</ul>
<p>La complessità temporale dell’applicazione ricorsiva dell’algoritmo è
espressa dalla seguente relazione di ricorrenza:</p>
<!-- prettier-ignore -->
<p><span class="math display">\[\begin{align*}
T(n) &amp;= 2T\left(\dfrac{n}{2}\right) + n &amp;&amp; \textrm{1
espansione} \\[8pt]
     &amp;= 2\left(2T\left(\dfrac{n}{4}\right) + \dfrac{n}{2}\right) + n
\\[8pt]
     &amp;= 4T\left(\dfrac{n}{4}\right) + 2n &amp;&amp; \textrm{2
espansioni} \\[8pt]
     &amp;= 4\left(2T\left(\dfrac{n}{8}\right) + \dfrac{n}{4}\right) +
2n \\[8pt]
     &amp;= 8T\left(\dfrac{n}{8}\right) + 3n &amp;&amp; \textrm{3
espansioni} \\[8pt]
     &amp;\quad \vdots \\[8pt]
     &amp;= 2^k T\left(\dfrac{n}{2^k}\right) + kn &amp;&amp; \textrm{k
espansioni}
\end{align*}\]</span></p>
<p>Cerchiamo <span class="math inline">\(k\)</span> tale che <span
class="math inline">\(\dfrac{n}{2^k} = 1\)</span>. Dunque <span
class="math inline">\(k = \log_2 n\)</span>.</p>
<!-- prettier-ignore -->
<p><span class="math display">\[\begin{align*}
T(n) &amp;= 2^{\log_2 n} T\left(\dfrac{n}{2^{\log_2 n}}\right) + (\log_2
n) n \\[8pt]
     &amp;= n T\left(\dfrac{n}{n}\right) + n \log_2 n \\[8pt]
     &amp;= n T(1) + n \log_2 n
\end{align*}\]</span></p>
<p>Per input di taglia 1, Divide and Conquer non esegue operazioni, e
dunque possiamo dire che <span class="math inline">\(T(1) =
1\)</span>.</p>
<!-- prettier-ignore -->
<p><span class="math display">\[\begin{align*}
T(n) &amp;= n + n \log_2 n \\[5pt]
     &amp;= O(n \hspace{0.25em}log \hspace{0.25em}n)
\end{align*}\]</span></p>
<h3 id="complessità-complessiva">Complessità complessiva</h3>
<p>Dunque, per quanto detto sopra la complessità temporale complessiva è
<span class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span> a causa dell’ordinamento.</p>
<h1 id="algoritmo-di-akl-toussaint">Algoritmo di Akl-Toussaint</h1>
<h2 id="idea-2">Idea</h2>
<p>L’idea dell’algoritmo di Akl-Toussaint è la seguente:</p>
<ul>
<li>Determiniamo il quadrilatero definito dai quattro punti estremi di
<span class="math inline">\(S\)</span>.</li>
<li>Tutti i punti che cadono all’interno di questo quadrilatero non
possono essere vertici dell’involucro convesso, quindi possono essere
scartati.</li>
<li>Per ciascun lato del quadrilatero, cerchiamo un percorso convesso
tra i punti della regione sottesa da quel lato.</li>
<li>L’unione di questi percorsi convessi costituisce l’involucro
convesso.</li>
</ul>
<h3 id="euristica">Euristica</h3>
<p>Determiniamo i seguenti punti di <span
class="math inline">\(S\)</span>:</p>
<ul>
<li><span class="math inline">\(\textrm{XMIN}\)</span>, di minima <span
class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(\textrm{YMAX}\)</span>, di massima <span
class="math inline">\(y\)</span>.</li>
<li><span class="math inline">\(\textrm{XMAX}\)</span>, di massima <span
class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(\textrm{YMIN}\)</span>, di minima <span
class="math inline">\(y\)</span>.</li>
</ul>
<p>Questi quattro punti appartengono certamente a <span
class="math inline">\(P(H)\)</span>. Oltretutto, osserviamo che tutti i
punti di <span class="math inline">\(S\)</span> che cadono all’interno
del quadrilatero di vertici <span
class="math inline">\(\textrm{XMIN}\)</span>, <span
class="math inline">\(\textrm{YMAX}\)</span>, <span
class="math inline">\(\textrm{XMAX}\)</span>, <span
class="math inline">\(\textrm{YMIN}\)</span>,
<strong>sicuramente</strong> non fanno parte di <span
class="math inline">\(P(H)\)</span>.</p>
<p>Dunque possiamo eliminare tali punti da <span
class="math inline">\(S\)</span>.</p>
<h3
id="ricerca-dei-percorsi-convessi-per-ogni-lato-del-quadrilatero">Ricerca
dei percorsi convessi per ogni lato del quadrilatero</h3>
<p><img src="./akl_toussaint_quadrilatero.svg"
style="height: 400px; display: block; margin: auto;" /></p>
<p>Osserviamo, sul disegno qui sopra, come ad ogni lato del quadrilatero
corrisponde una regione. Quello che facciamo è percorrere il
quadrilatero in senso orario e, per ogni regione, cercare il percorso
convesso che ci porta da un estremo all’altro del lato corrispondente la
suddetta regione.</p>
<h3 id="costruzione-dellinvolucro-convesso-h">Costruzione dell’involucro
convesso H</h3>
<p>Una volta che abbiamo determinato i vari percorsi convessi per le
relative regioni, andiamo a unirli seguendo il senso orario di
percorrenza dei lati del quadrilatero. Dalla loro unione risulta <span
class="math inline">\(H\)</span>.</p>
<h2 id="ricerca-di-un-percorso-convesso-di-una-data-regione">Ricerca di
un percorso convesso di una data regione</h2>
<p>Sia <span class="math inline">\(R\)</span> l’insieme di punti che
cadono nella regione (compresi gli estremi del lato corrispondenti alla
regione).</p>
<p>Se siamo nella regione 1, o nella regione 2, ordiniamo i punti di
<span class="math inline">\(R\)</span> in ordine crescente di <span
class="math inline">\(x\)</span>, ottenendo così una lista di punti
<span class="math inline">\(P\)</span>.</p>
<p>Se siamo nella regione 3, o nella regione 4, ordiniamo i punti di
<span class="math inline">\(R\)</span> in ordine decrescente di <span
class="math inline">\(x\)</span>, ottenendo così una lista di punti
<span class="math inline">\(P\)</span>.</p>
<ol type="1">
<li><p>Per ogni tripla di punti consecutivi <span
class="math inline">\((P_k, P_{k+1}, P_{k+2})\)</span> in <span
class="math inline">\(P\)</span>:</p>
<ul>
<li><p>Calcoliamo <span class="math inline">\(det \begin{pmatrix}
(P_{k+2} - P_{k+1})_x &amp; (P_{k+1} - P_{k})_x \\ (P_{k+2} - P_{k+1})_y
&amp; (P_{k+1} - P_{k})_y \end{pmatrix}\)</span></p></li>
<li><p>Se tale determinante è:</p>
<ul>
<li><p>Maggiore o uguale a 0, passiamo alla successiva tripla <span
class="math inline">\((P_{k+1}, P_{k+2}, P_{k+3})\)</span> di punti
consecutivi in <span class="math inline">\(P\)</span>.</p></li>
<li><p>Minore di 0, eliminiamo il punto <span
class="math inline">\(P_{k+1}\)</span> dalla lista <span
class="math inline">\(P\)</span> e passiamo alla tripla <span
class="math inline">\((P_{k-1}, P_k, P_{k+2})\)</span> di punti
consecutivi in <span class="math inline">\(P\)</span>.</p></li>
</ul></li>
</ul></li>
<li><p>Se abbiamo completato (1) senza avere rimosso nessun punto di
<span class="math inline">\(P\)</span>, allora ci fermiamo, altrimenti
ripetiamo (1).</p></li>
</ol>
<p>Quando ci fermeremo, la lista <span class="math inline">\(P\)</span>
sarà proprio la lista di punti, in senso orario, del lato del poligono
convesso che stavamo cercando.</p>
<p><img src="./akl_toussaint_determinante.svg"
style="height: 300px; display: block; margin: auto;" /></p>
<h2 id="complessità-temporale-2">Complessità temporale</h2>
<h3 id="euristica-1">Euristica</h3>
<ol type="1">
<li>Cercare <span class="math inline">\(\textrm{XMIN}\)</span>, <span
class="math inline">\(\textrm{YMAX}\)</span>, <span
class="math inline">\(\textrm{XMAX}\)</span>, <span
class="math inline">\(\textrm{YMIN}\)</span> richiede una semplice
scansione di <span class="math inline">\(S\)</span> quindi la
complessità è <span class="math inline">\(O(n)\)</span></li>
<li>Eliminare i punti di <span class="math inline">\(S\)</span> che
cadono all’interno del quadrilatero richiede, per ciascun punto, fino a
quattro half-plane test (uno per ogni lato del quadrilatero) la
complessità è <span class="math inline">\(O(n)\)</span></li>
</ol>
<h3 id="ricerca-del-percorso-convesso">Ricerca del percorso
convesso</h3>
<ul>
<li><p>Ordinamento dei punti della regione <span
class="math inline">\(\rightarrow O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span></p></li>
<li><p>Convessificazione <span class="math inline">\(\rightarrow
O(n)\)</span></p>
<p>Il processo di convessificazione di <span
class="math inline">\(P\)</span> è una scansione di <span
class="math inline">\(P\)</span>, nella quale possiamo procedere
effettuando sia passi in avanti (andando alla tripla di punti
successiva) che passi indietro (andando alla tripla di punti
precedente).</p>
<p>Un modo per determinare la complessità temporale della scansione è
quello di contare il numero di passi da essa effettuati.</p>
<ul>
<li><p>Siccome in <span class="math inline">\(P\)</span> vi sono al più
<span class="math inline">\(n\)</span> punti, il numero di passi in
avanti che possiamo fare è <span class="math inline">\(\le
n\)</span>.</p></li>
<li><p>Ogniqualvolta esaminiamo una tripla di punti consecutivi in <span
class="math inline">\(P\)</span>, c’è la possibilità di effettuare un
passo indietro. Osserviamo come, quando effettuiamo un passo indietro,
andiamo anche a rimuovere un punto da <span
class="math inline">\(P\)</span>. Siccome in <span
class="math inline">\(P\)</span> vi sono al più <span
class="math inline">\(n\)</span> punti, il numero totale di passi
indietro che possiamo fare è <span class="math inline">\(\le
n\)</span>.</p></li>
</ul></li>
</ul>
<p>In conclusione, il numero totale di passi che possiamo fare è <span
class="math inline">\(\le n + n\)</span>, ovvero <span
class="math inline">\(\le 2n\)</span>.</p>
<p>Dunque, la complessità della ricerca del percorso convesso è <span
class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<h3 id="costruzione-di-h-1">Costruzione di H</h3>
<p>Per costruire <span class="math inline">\(H\)</span> è sufficiente
unire i percorsi convessi trovati <span
class="math inline">\(\rightarrow O(n)\)</span></p>
<h3 id="complessità-complessiva-1">Complessità complessiva</h3>
<p>Di conseguenza, la complessità temporale complessiva è <span
class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<h1 id="torch-total-order-heuristic-based-convex-hull">TORCH: Total
Order Heuristic Based Convex Hull</h1>
<h2 id="idea-3">Idea</h2>
<p>A grandi linee TORCH:</p>
<ol type="1">
<li>Ordina <span class="math inline">\(S\)</span>.</li>
<li>Costruisce un involucro approssimato <strong>non</strong> convesso
<span class="math inline">\(H&#39;\)</span>.</li>
<li>Costruisce <span class="math inline">\(H\)</span> a partire da <span
class="math inline">\(H&#39;\)</span> usando un processo di
<strong>convessificazione</strong>.</li>
</ol>
<h2 id="ordinamento-di-s">Ordinamento di S</h2>
<p>Ordiniamo i punti di <span class="math inline">\(S\)</span> in ordine
crescente di <span class="math inline">\(x\)</span>, ottenendo una lista
di punti <span class="math inline">\(P\)</span>.</p>
<h2 id="costruzione-di-h-2">Costruzione di H’</h2>
<p><img src="./torch_lateral_hulls.svg"
style="height: 300px; display: block; margin: auto;" /></p>
<p>Siano:</p>
<ul>
<li><span class="math inline">\(W\)</span>, il punto di <span
class="math inline">\(P\)</span> con <span
class="math inline">\(x\)</span> minima.</li>
<li><span class="math inline">\(E\)</span>, il punto di <span
class="math inline">\(P\)</span> con <span
class="math inline">\(x\)</span> massima.</li>
<li><span class="math inline">\(S\)</span>, il punto di <span
class="math inline">\(P\)</span> con <span
class="math inline">\(y\)</span> minima.</li>
<li><span class="math inline">\(N\)</span>, il punto di <span
class="math inline">\(P\)</span> con <span
class="math inline">\(y\)</span> massima.</li>
</ul>
<p>Troviamo i quattro percorsi seguenti, detti “involucri laterali”:</p>
<ul>
<li><span class="math inline">\(\Pi_{nw}\)</span>, da <span
class="math inline">\(W\)</span> a <span
class="math inline">\(N\)</span></li>
<li><span class="math inline">\(\Pi_{ne}\)</span>, da <span
class="math inline">\(E\)</span> a <span
class="math inline">\(N\)</span></li>
<li><span class="math inline">\(\Pi_{sw}\)</span>, da <span
class="math inline">\(W\)</span> a <span
class="math inline">\(S\)</span></li>
<li><span class="math inline">\(\Pi_{se}\)</span>, da <span
class="math inline">\(E\)</span> a <span
class="math inline">\(S\)</span></li>
</ul>
<p>Costruiamo <span class="math inline">\(H&#39;\)</span> concatenando
<span class="math inline">\(\Pi_{nw}, \Pi_{ne}, \Pi_{sw}
\hspace{0.5em}\textrm{e} \hspace{0.5em}\Pi_{se}\)</span> in modo
appropriato.</p>
<h3 id="costruzione-dellinvolucro-laterale-nw">Costruzione
dell’involucro laterale NW</h3>
<p>Costruiamo <span class="math inline">\(\Pi_{nw}\)</span> nel modo
seguente:</p>
<ul>
<li>All’inizio <span class="math inline">\(\Pi_{nw} = W\)</span>.</li>
<li>Effettuiamo una scansione di <span class="math inline">\(P\)</span>,
andando da <span class="math inline">\(W\)</span> a <span
class="math inline">\(N\)</span>, e ogni volta che incontriamo un punto
<span class="math inline">\(p\)</span>, con coordinata <span
class="math inline">\(y\)</span> maggiore della massima <span
class="math inline">\(y\)</span> incontrata durante la scansione di
<span class="math inline">\(P\)</span>, da <span
class="math inline">\(W\)</span> fino a <span
class="math inline">\(p\)</span>, aggiungiamo <span
class="math inline">\(p\)</span> in coda a <span
class="math inline">\(\Pi_{nw}\)</span>.</li>
</ul>
<p>Possiamo osservare che, alla fine della sua costruzione, <span
class="math inline">\(\Pi_{nw}\)</span> avrà la struttura seguente:</p>
<p><span class="math display">\[\Pi_{nw} : W = p_0, p_1, p_2, ...,
p_{k_{nw}} = N\]</span></p>
<p>dove</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., k_{nw} \quad
(p_{i-1})_x &lt; (p_i)_x\)</span></li>
<li><span class="math inline">\(\forall i = 1, ..., k_{nw} \quad
(p_{i-1})_y &lt; (p_i)_y\)</span></li>
</ul>
<h3 id="costruzione-dellinvolucro-laterale-ne">Costruzione
dell’involucro laterale NE</h3>
<p>Costruiamo <span class="math inline">\(\Pi_{ne}\)</span> in modo
molto simile a come abbiamo costruito <span
class="math inline">\(\Pi_{nw}\)</span>. L’unica differenza è che
partiamo da <span class="math inline">\(E\)</span>, invece che da <span
class="math inline">\(W\)</span>, e che facciamo la scansione di <span
class="math inline">\(P\)</span> da <span
class="math inline">\(E\)</span> a <span
class="math inline">\(N\)</span>, invece che da <span
class="math inline">\(W\)</span> a <span
class="math inline">\(N\)</span>.</p>
<p>Possiamo osservare che alla fine della sua costruzione, <span
class="math inline">\(\Pi_{ne}\)</span> avrà la struttura seguente:</p>
<p><span class="math display">\[\Pi_{ne} : E = p_0, p_1, p_2, ...,
p_{k_{ne}} = N\]</span></p>
<p>dove</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., k_{ne} \quad
(p_{i-1})_x &gt; (p_i)_x\)</span></li>
<li><span class="math inline">\(\forall i = 1, ..., k_{ne} \quad
(p_{i-1})_y &lt; (p_i)_y\)</span></li>
</ul>
<h3 id="costruzione-dellinvolucro-laterale-sw">Costruzione
dell’involucro laterale SW</h3>
<p>Costruiamo <span class="math inline">\(\Pi_{sw}\)</span> nel modo
seguente:</p>
<ul>
<li>All’inizio <span class="math inline">\(\Pi_{sw} = W\)</span>.</li>
<li>Effettuiamo una scansione di <span class="math inline">\(P\)</span>,
andando da <span class="math inline">\(W\)</span> a <span
class="math inline">\(S\)</span>, e ogni volta che incontriamo un punto
<span class="math inline">\(p\)</span>, con coordinata <span
class="math inline">\(y\)</span> minore della minima <span
class="math inline">\(y\)</span> incontrata durante la scansione di
<span class="math inline">\(P\)</span>, da <span
class="math inline">\(W\)</span> fino a <span
class="math inline">\(p\)</span>, aggiungiamo <span
class="math inline">\(p\)</span> in coda a <span
class="math inline">\(\Pi_{sw}\)</span>.</li>
</ul>
<p>Possiamo osservare che, alla fine della sua costruzione, <span
class="math inline">\(\Pi_{sw}\)</span> avrà la struttura seguente:</p>
<p><span class="math display">\[\Pi_{sw} : W = p_0, p_1, p_2, ...,
p_{k_{sw}} = S\]</span></p>
<p>dove</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., k_{sw} \quad
(p_{i-1})_x &lt; (p_i)_x\)</span></li>
<li><span class="math inline">\(\forall i = 1, ..., k_{sw} \quad
(p_{i-1})_y &gt; (p_i)_y\)</span></li>
</ul>
<h3 id="costruzione-dellinvolucro-laterale-se">Costruzione
dell’involucro laterale SE</h3>
<p>Costruiamo <span class="math inline">\(\Pi_{se}\)</span> in modo
molto simile a come abbiamo costruito <span
class="math inline">\(\Pi_{sw}\)</span>. L’unica differenza è che
partiamo da <span class="math inline">\(E\)</span>, invece che da <span
class="math inline">\(W\)</span>, e che facciamo la scansione di <span
class="math inline">\(P\)</span> da <span
class="math inline">\(E\)</span> a <span
class="math inline">\(S\)</span>, invece che da <span
class="math inline">\(W\)</span> a <span
class="math inline">\(S\)</span>.</p>
<p>Possiamo osservare che alla fine della sua costruzione, <span
class="math inline">\(\Pi_{se}\)</span> avrà la struttura seguente:</p>
<p><span class="math display">\[\Pi_{se} : E = p_0, p_1, p_2, ...,
p_{k_{se}} = S\]</span></p>
<p>dove</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., k_{se} \quad
(p_{i-1})_x &gt; (p_i)_x\)</span></li>
<li><span class="math inline">\(\forall i = 1, ..., k_{se} \quad
(p_{i-1})_y &gt; (p_i)_y\)</span></li>
</ul>
<h3 id="concatenazione-degli-involucri-laterali">Concatenazione degli
involucri laterali</h3>
<p>Costruiamo <span class="math inline">\(H&#39;\)</span> nel modo
seguente:</p>
<ul>
<li>Percorriamo <span class="math inline">\(\Pi_{nw}\)</span> da <span
class="math inline">\(W\)</span> a <span
class="math inline">\(N\)</span> e aggiungiamo in coda ad <span
class="math inline">\(H&#39;\)</span> ogni punto che incontriamo (tranne
<span class="math inline">\(N\)</span>).</li>
<li>Percorriamo <span class="math inline">\(\Pi_{ne}\)</span> da <span
class="math inline">\(N\)</span> a <span
class="math inline">\(E\)</span> e aggiungiamo in coda ad <span
class="math inline">\(H&#39;\)</span> ogni punto che incontriamo (tranne
<span class="math inline">\(E\)</span>).</li>
<li>Percorriamo <span class="math inline">\(\Pi_{se}\)</span> da <span
class="math inline">\(E\)</span> a <span
class="math inline">\(S\)</span> e aggiungiamo in coda ad <span
class="math inline">\(H&#39;\)</span> ogni punto che incontriamo (tranne
<span class="math inline">\(S\)</span>).</li>
<li>Percorriamo <span class="math inline">\(\Pi_{sw}\)</span> da <span
class="math inline">\(S\)</span> a <span
class="math inline">\(W\)</span> e aggiungiamo in coda ad <span
class="math inline">\(H&#39;\)</span> ogni punto che incontriamo (tranne
<span class="math inline">\(W\)</span>).</li>
</ul>
<h3 id="convessificazione-di-h">Convessificazione di H’</h3>
<p>Possiamo notare come, per costruzione di <span
class="math inline">\(H&#39;\)</span> si ha che <span
class="math inline">\(P(H) \subseteq P(H&#39;)\)</span>. In particolare,
<span class="math inline">\(H&#39;\)</span> contiene già tutti i punti
di <span class="math inline">\(H\)</span>, possibilmente assieme ad
alcuni punti aggiuntivi che rendono <span
class="math inline">\(H&#39;\)</span> concavo. Convessificare <span
class="math inline">\(H&#39;\)</span> significa dunque rimuovere quei
punti di <span class="math inline">\(H&#39;\)</span> che lo rendono
concavo.</p>
<p>Per convessificare <span class="math inline">\(H&#39;\)</span>
possiamo usare lo stesso procedimento che abbiamo presentato durante la
trattazione di Akl-Toussaint, in merito alla ricerca di un percorso
convesso.</p>
<p>Facciamo notare come in questo caso non è necessario ordinare <span
class="math inline">\(H&#39;\)</span>, siccome, per costruzione questo è
già nell’ordine desiderato.</p>
<h3 id="complessità-temporale-3">Complessità temporale</h3>
<ul>
<li><p>Ordinamento di S <span class="math inline">\(\rightarrow O(n
\hspace{0.25em}log \hspace{0.25em}n)\)</span></p></li>
<li><p>Costruzione di <span class="math inline">\(H&#39;\)</span> <span
class="math inline">\(\rightarrow O(n)\)</span></p>
<ul>
<li><p>Ricerca di <span class="math inline">\(W\)</span> e <span
class="math inline">\(E\)</span> <span class="math inline">\(\rightarrow
O(1)\)</span></p></li>
<li><p>Ricerca di <span class="math inline">\(N\)</span> e <span
class="math inline">\(S\)</span> <span class="math inline">\(\rightarrow
O(n)\)</span></p></li>
<li><p>Costruzione di <span class="math inline">\(\Pi_{nw}\)</span>
<span class="math inline">\(\rightarrow O(n)\)</span></p></li>
<li><p>Costruzione di <span class="math inline">\(\Pi_{ne}\)</span>
<span class="math inline">\(\rightarrow O(n)\)</span></p></li>
<li><p>Costruzione di <span class="math inline">\(\Pi_{sw}\)</span>
<span class="math inline">\(\rightarrow O(n)\)</span></p></li>
<li><p>Costruzione di <span class="math inline">\(\Pi_{se}\)</span>
<span class="math inline">\(\rightarrow O(n)\)</span></p></li>
<li><p>Concatenazione di <span class="math inline">\(\Pi_{nw}, \Pi_{ne},
\Pi_{sw}, \Pi_{se} \rightarrow O(n)\)</span></p></li>
</ul></li>
<li><p>Convessificazione <span class="math inline">\(\rightarrow
O(n)\)</span></p></li>
</ul>
<p>Dunque, la complessità temporale dell’algoritmo è <span
class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<h1
id="benchmark-degli-algoritmi-per-il-calcolo-dellinvolucro-convesso">Benchmark
degli algoritmi per il calcolo dell’involucro convesso</h1>
<canvas id="canvas" width="600" height="400">
</canvas>
<h1
id="algoritmo-di-approssimazione-di-bentley-faust-e-preparata">Algoritmo
di approssimazione di Bentley, Faust e Preparata</h1>
<p>Un algoritmo di approssimazione, al contrario dei classici algoritmi
che più comunemente si studiano, non da garanzie di trovare la soluzione
corretta, bensì ne trova una che, in generale, sarà “abbastanza
buona”.</p>
<p>Con “abbastanza buona” si intende che la distanza tra la soluzione
approssimata e quella corretta è minore di un dato valore di soglia. La
funzione distanza tra le due soluzioni, di norma, emerge naturalmente
dalla natura del problema trattato, e dalle sue soluzioni.</p>
<p>Usiamo un algoritmo di approssimazione quando per noi non è
strettamente necessario trovare la soluzione esatta.</p>
<p>Ha senso pratico usare un algoritmo di approssimazione solo nel caso
in cui il suo tempo di esecuzione sia inferiore al tempo di esecuzione
di un qualsiasi algoritmo esatto per il problema. Se questo non fosse il
caso, potremmo direttamente trovare la soluzione esatta in un tempo
inferiore rispetto a quella approssimata.</p>
<h2 id="idea-4">Idea</h2>
<p>Presentiamo ora uno schema generale per la definizione di algoritmi
di approssimazione per il problema dell’involucro convesso:</p>
<ol type="1">
<li>Sia <span class="math inline">\(S&#39;\)</span> un insieme di punti
determinato a partire da <span class="math inline">\(S\)</span>.</li>
<li>Determiniamo <span class="math inline">\(H&#39;\)</span>,
l’involucro convesso di <span class="math inline">\(S&#39;\)</span>,
eseguendo un algoritmo per la ricerca dell’involucro convesso su <span
class="math inline">\(S&#39;\)</span>.</li>
<li>Usiamo <span class="math inline">\(H&#39;\)</span> come soluzione
approssimata per <span class="math inline">\(H\)</span>.</li>
</ol>
<h3 id="complessità-temporale-4">Complessità temporale</h3>
<p>Sia:</p>
<ul>
<li><span class="math inline">\(T_{s&#39;}\)</span> la funzione che
caratterizza la complessità temporale del della determinazione di <span
class="math inline">\(S&#39;\)</span>.</li>
<li><span class="math inline">\(m = | S&#39; |\)</span></li>
<li><span class="math inline">\(T\)</span> la funzione che caratterizza
la complessità temporale dell’algoritmo usato per trovare <span
class="math inline">\(H&#39;\)</span>.</li>
</ul>
<p>Dunque, è chiaro che la complessità temporale di un qualsiasi
algoritmo di approssimazione che usa lo schema presentato sopra è:</p>
<p><span class="math display">\[T_{s&#39;}(n) + T(m)\]</span></p>
<h2 id="determinazione-di-s">Determinazione di S’</h2>
<p>L’aspetto più interessante dello schema generale per la definizione
di algoritmi di approssimazione per l’involucro convesso è la
determinazione di <span class="math inline">\(S&#39;\)</span>. Vi sono
innumerevoli strategie che possiamo usare per determinare <span
class="math inline">\(S&#39;\)</span>. Quella che presenteremo è stata
proposta da Bentley, Faust e Preparata nel 1988.</p>
<p>Consideriamo i quattro punti seguenti di <span
class="math inline">\(S\)</span>:</p>
<ul>
<li><span class="math inline">\(\textrm{XMAX}\)</span>, di massima <span
class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(\textrm{XMIN}\)</span>, di minima <span
class="math inline">\(x\)</span>.</li>
<li><span class="math inline">\(\textrm{YMAX}\)</span>, di massima <span
class="math inline">\(y\)</span>.</li>
<li><span class="math inline">\(\textrm{YMIN}\)</span>, di minima <span
class="math inline">\(y\)</span>.</li>
</ul>
<p>Poniamo <span class="math inline">\(S&#39; = \{ \textrm{XMIN},
\textrm{XMAX}, \textrm{YMIN}, \textrm{YMAX} \}\)</span>. È chiaro che
<span class="math inline">\(H&#39;\)</span> è il quadrilatero convesso
<span class="math inline">\(Q\)</span> di vertici <span
class="math inline">\(\textrm{XMIN}, \textrm{XMAX}, \textrm{YMIN},
\textrm{YMAX}\)</span>.</p>
<h3 id="proprietà">Proprietà</h3>
<p>Per ogni punto <span class="math inline">\(p \in S\)</span>, se <span
class="math inline">\(p\)</span> cade al di fuori del quadrilatero <span
class="math inline">\(Q\)</span> allora la distanza tra <span
class="math inline">\(p\)</span> e <span
class="math inline">\(Q\)</span> è al più <span
class="math inline">\(\Delta X\)</span>, dove <span
class="math inline">\(\Delta X = \textrm{XMAX}_x -
\textrm{XMIN}_x\)</span>.</p>
<h4 id="dimostrazione-1">Dimostrazione</h4>
<p>Sia <span class="math inline">\(R\)</span> il rettangolo con
diagonale il segmento di estremi <span
class="math inline">\((\textrm{XMIN}_x, \textrm{YMIN}_y)\)</span> e
<span class="math inline">\((\textrm{XMAX}_x,
\textrm{YMAX}_y)\)</span>.</p>
<p>È facile vedere che tutti i punti <span class="math inline">\(p \in
S\)</span> cadono all’interno di <span
class="math inline">\(R\)</span>.</p>
<p>Un qualsiasi punto <span class="math inline">\(p \in S\)</span> che
cade al di fuori del quadrilatero deve essere in una delle quattro
regioni <span class="math inline">\(A, B, C \hspace{0.25em}o
\hspace{0.25em}D\)</span> sotto riportate.</p>
<p><img src="./q_and_r.svg"
style="height: 350px; display: block; margin: auto;" /></p>
<p>Prendiamo, senza perdita di generalità, un generico punto <span
class="math inline">\(p \in S\)</span> che cade nella regione <span
class="math inline">\(A\)</span>. Naturalmente, la distanza <span
class="math inline">\(\delta\)</span> tra <span
class="math inline">\(p\)</span> e <span
class="math inline">\(Q\)</span> è data dalla distanza tra <span
class="math inline">\(p\)</span> e il segmento <span
class="math inline">\(\textrm{XMIN}, \textrm{YMAX}\)</span>.</p>
<p>Denotiamo con <span class="math inline">\(\delta x\)</span>, la
lunghezza del segmento con estremi:</p>
<ul>
<li><span class="math inline">\(p\)</span>, e</li>
<li>il punto di intersezione tra il segmento <span
class="math inline">\(\textrm{XMIN}, \textrm{YMAX}\)</span> e la retta
parallela all’asse delle <span class="math inline">\(x\)</span> passante
per <span class="math inline">\(p\)</span>.</li>
</ul>
<p><img src="./distance_and_dx_quad.svg"
style="height: 350px; display: block; margin: auto;" /></p>
<p>È facile osservare come <span class="math inline">\(\delta \le \delta
x \le \Delta X\)</span>. <span
class="math inline">\(\square\)</span></p>
<p>Possiamo immaginare di aver determinato <span
class="math inline">\(S&#39;\)</span> nel modo seguente:</p>
<ul>
<li><p>Aggiungiamo a <span class="math inline">\(S&#39;\)</span> il
punto <span class="math inline">\(\textrm{XMIN}\)</span>.</p></li>
<li><p>Aggiungiamo a <span class="math inline">\(S&#39;\)</span> il
punto <span class="math inline">\(\textrm{XMAX}\)</span>.</p></li>
<li><p>Consideriamo l’intervallo <span
class="math inline">\([\textrm{XMIN}_x, \textrm{XMAX}_x]\)</span>.
Questo può essere visto come una striscia verticale sul piano. Tutti i
punti di <span class="math inline">\(S\)</span> cadono all’interno di
questa striscia. Cerchiamo i due punti della striscia con <span
class="math inline">\(y\)</span> minima e <span
class="math inline">\(y\)</span> massima e li aggiungiamo a <span
class="math inline">\(S&#39;\)</span>.</p></li>
</ul>
<p>Possiamo estendere la costruzione esposta sopra ad un generico numero
<span class="math inline">\(k\)</span> di strisce di larghezza
uniforme:</p>
<ul>
<li><p>Aggiungiamo a <span class="math inline">\(S&#39;\)</span> il
punto <span class="math inline">\(\textrm{XMIN}\)</span>.</p></li>
<li><p>Aggiungiamo a <span class="math inline">\(S&#39;\)</span> il
punto <span class="math inline">\(\textrm{XMAX}\)</span>.</p></li>
<li><p>Consideriamo l’intervallo <span
class="math inline">\([\textrm{XMIN}_x, \textrm{XMAX}_x]\)</span> e lo
partizioniamo in <span class="math inline">\(k\)</span> sotto intervalli
(strisce), ognuno di ampiezza <span class="math inline">\(\dfrac{\Delta
X}{k}\)</span>.</p></li>
<li><p>Per ogni sotto intervallo (striscia), cerchiamo, tra i punti di
<span class="math inline">\(S\)</span> che cadono nella striscia, i due
che hanno <span class="math inline">\(y\)</span> minima e <span
class="math inline">\(y\)</span> massima, e li aggiungiamo a <span
class="math inline">\(S&#39;\)</span>.</p></li>
</ul>
<p><strong>Osservazione:</strong> Possiamo osservare che, per
costruzione di <span class="math inline">\(S&#39;\)</span> si ha che
<span class="math inline">\(P(H&#39;) \subseteq P(H)\)</span>.</p>
<h3 id="proprietà-1">Proprietà</h3>
<p>Per ogni punto <span class="math inline">\(p \in S\)</span>, se <span
class="math inline">\(p\)</span> cade al di fuori di <span
class="math inline">\(H&#39;\)</span> <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
allora la distanza tra <span class="math inline">\(p\)</span> e <span
class="math inline">\(H&#39;\)</span> è al più <span
class="math inline">\(\dfrac{\Delta X}{k}\)</span>.</p>
<h4 id="dimostrazione-2">Dimostrazione</h4>
<p><img src="./bfp_example.svg"
style="height: 350px; display: block; margin: auto;" /></p>
<p>Consideriamo un qualsiasi punto <span class="math inline">\(p \in
S\)</span> che cade al di fuori di <span
class="math inline">\(H&#39;\)</span>. Per costruzione, <span
class="math inline">\(p\)</span> deve cadere all’interno di una data
striscia.</p>
<p>Siccome <span class="math inline">\(p\)</span> cade al di fuori di
<span class="math inline">\(H&#39;\)</span>, <span
class="math inline">\(p\)</span> non è stato preso dal campionamento, e
dunque <span class="math inline">\(p\)</span> non può né avere <span
class="math inline">\(y\)</span> minima né <span
class="math inline">\(y\)</span> massima nella striscia in cui cade.
Dunque, <span class="math inline">\(p_y\)</span> deve essere compreso
tra questi due valori, esclusi. Perciò, nella striscia in cui cade <span
class="math inline">\(p\)</span>, devono cadere almeno altri due punti.
Oltretutto, almeno un punto <span class="math inline">\(h\)</span> tra
questi due deve appartenere a <span
class="math inline">\(P(H&#39;)\)</span>. Dunque, la distanza <span
class="math inline">\(\delta\)</span> tra <span
class="math inline">\(p\)</span> e <span
class="math inline">\(H&#39;\)</span> è data dalla distanza di <span
class="math inline">\(p\)</span> da uno dei due lati di <span
class="math inline">\(H&#39; \cap \{ \textrm{striscia} \}\)</span>,
quella che ha <span class="math inline">\(h\)</span> come uno dei due
estremi.</p>
<p>Denotiamo con <span class="math inline">\(\delta x\)</span> la
lunghezza del segmento che ha come estremi:</p>
<ul>
<li><span class="math inline">\(p\)</span>, e</li>
<li>l’intersezione tra il suddetto lato di <span
class="math inline">\(H&#39;\)</span> e la retta parallela all’asse
<span class="math inline">\(x\)</span> passante per <span
class="math inline">\(p\)</span>.</li>
</ul>
<p><img src="./distance_and_dx_strip.svg"
style="height: 350px; display: block; margin: auto;" /></p>
<p>Possiamo vedere che <span class="math inline">\(\delta \le \delta x
\le \dfrac{\Delta X}{k}\)</span>. <span
class="math inline">\(\square\)</span></p>
<aside id="footnotes-2" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="2">
<li id="fn2"><p>Questo significa che <span
class="math inline">\(p\)</span> non è stato preso dal campionamento.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 id="corollario">Corollario</h3>
<p>Per ogni punto <span class="math inline">\(p \in S\)</span>, se <span
class="math inline">\(p\)</span> cade al di fuori di <span
class="math inline">\(H&#39;\)</span> allora la distanza tra <span
class="math inline">\(p\)</span> e <span
class="math inline">\(H&#39;\)</span> è al più <span
class="math inline">\(\dfrac{D}{k}\)</span>, dove <span
class="math inline">\(D\)</span> è il diametro di <span
class="math inline">\(S\)</span>. Il diametro è definito come la massima
distanza tra due generici punti di <span
class="math inline">\(S\)</span>.</p>
<h4 id="dimostrazione-3">Dimostrazione</h4>
<p>Per definizione di <span class="math inline">\(D\)</span>, <span
class="math inline">\(\Delta X \le D\)</span>. Questo assieme a quanto
dimostrato precedentemente è sufficiente a provare il corollario. <span
class="math inline">\(\square\)</span></p>
<h3 id="complessità-temporale-5">Complessità temporale</h3>
<ol type="1">
<li>Ricerca di <span class="math inline">\(\textrm{XMIN}\)</span> e
<span class="math inline">\(\textrm{XMAX}\)</span> <span
class="math inline">\(\rightarrow O(n)\)</span></li>
<li>Partizionamento dell’intervallo <span
class="math inline">\([\textrm{XMIN}_x, \textrm{XMAX}_x]\)</span> in
<span class="math inline">\(k\)</span> sotto intervalli <span
class="math inline">\(\rightarrow O(n)\)</span></li>
<li>Ricerca dei punti di <span class="math inline">\(y\)</span> minima e
<span class="math inline">\(y\)</span> massima per ogni sotto intervallo
<span class="math inline">\(\rightarrow O(n)\)</span></li>
</ol>
<p>Dunque, la complessità dell’algoritmo è <span
class="math inline">\(O(n)\)</span>.</p>
</body>
</html>
