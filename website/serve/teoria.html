<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Teoria</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="style.css" />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Noto%20Serif"
  />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=JetBrains+Mono"
  />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<nav>
  <a href="/index.html">home</a>
  <a href="/teoria.html">teoria</a>
  <a href="/benchmark.html">benchmark</a>
  <a href="/manuale.html">manuale</a>
  <a href="/applicazione.html">applicazione</a>
</nav>
<h1 id="indice">Indice <!-- omit in toc --></h1>
<ul>
<li><a href="#involucro-convesso">Involucro convesso</a>
<ul>
<li><a href="#lower-bound-della-complessità-del-problema">Lower bound
della complessità del problema</a>
<ul>
<li><a href="#dimostrazione">Dimostrazione</a></li>
</ul></li>
</ul></li>
<li><a href="#involucro-convesso-naive">Involucro convesso naive</a>
<ul>
<li><a href="#idea-dellalgoritmo-naive">Idea dell’algoritmo
naive</a></li>
<li><a href="#complessità-temporale">Complessità temporale</a></li>
<li><a
href="#come-controllare-se-vecp-cade-in-pi-hquad-textrmo-hquad-pi-">Come
controllare se <span class="math inline">\(\\vec{p}\)</span> cade in
<span class="math inline">\(\\Pi^+ \\hquad \\textrm{o} \\hquad
\\Pi^-\)</span>?</a></li>
<li><a href="#come-trovare-un-vettore-perpendicolare-ad-un-altro">Come
trovare un vettore perpendicolare ad un altro?</a></li>
</ul></li>
</ul>
<h1 id="involucro-convesso">Involucro convesso</h1>
<p><strong>Input</strong>: Insieme finito <span class="math inline">\(S
\subseteq R^2\)</span>.</p>
<p><strong>Output</strong>: Poligono convesso <span
class="math inline">\(H\)</span> di area minima che contiene tutti i
punti di <span class="math inline">\(S\)</span>.</p>
<p><strong>Notazione</strong></p>
<p>Denotiamo con:</p>
<ul>
<li><span class="math inline">\(P(H)\)</span> l’insieme di vertici di
<span class="math inline">\(H\)</span>.</li>
<li><span class="math inline">\(d\)</span> la cardinalità di <span
class="math inline">\(P(H)\)</span>.</li>
<li><span class="math inline">\(n\)</span> la cardinalità di <span
class="math inline">\(S\)</span>.</li>
</ul>
<p><strong>Proprietà</strong>: <span class="math inline">\(P(H)
\subseteq S\)</span>.</p>
<p><strong>Corollario</strong>: <span class="math inline">\(d \le
n\)</span></p>
<p><strong>Rappresentare <span
class="math inline">\(H\)</span></strong></p>
<p>Rappresentiamo <span class="math inline">\(H\)</span> usando una
lista ordinata di punti di <span
class="math inline">\(P(H)\)</span>:</p>
<p><span class="math display">\[P_1, P_2, P_3, ..., P_d \qquad P_i \in
P(H), i = 1, ..., d\]</span></p>
<p>Tale che:</p>
<ul>
<li><span class="math inline">\(\forall i = 1, ..., d - 1\)</span> il
segmento di estremi <span class="math inline">\(P_i\)</span> e <span
class="math inline">\(P_{i+1}\)</span> è un lato di <span
class="math inline">\(H\)</span>.</li>
<li>Il segmento di estremi <span class="math inline">\(P_d\)</span> e
<span class="math inline">\(P_1\)</span> è un lato di <span
class="math inline">\(H\)</span>.</li>
</ul>
<h2 id="lower-bound-della-complessità-del-problema">Lower bound della
complessità del problema</h2>
<p>Il lower bound del problema è <span class="math inline">\(\Omega(n
\hspace{0.25em}log \hspace{0.25em}n)\)</span>.</p>
<h3 id="dimostrazione">Dimostrazione</h3>
<p>Supponiamo di avere il seguente insieme finito di numeri</p>
<p><span class="math display">\[I = { x_1, x_2, x_3, ..., x_n }
\subseteq \mathbb{R} \quad \textrm{dove} \quad x_1 &lt; x_2 &lt; x_3
&lt; ... &lt; x_n\]</span></p>
<p>È facile vedere che i punti di <span class="math inline">\(S\)</span>
giacciono su una parabola. Proprio per questo, è facile che un possibile
involucro convesso di <span class="math inline">\(S\)</span> è dato
dalla lista <span class="math inline">\((x_1, x_1^2), (x_2, x_2^2), ...,
(x_n, x_n^2)\)</span>.</p>
<p>Se ottenessimo una qualsiasi altra lista, potremmo ottenere quella
mostrata sopra in tempo <span class="math inline">\(O(d)\)</span> e
dunque <span class="math inline">\(O(n)\)</span>.</p>
<p>Supponiamo ora, per assurdo, di essere in grado di trovare
l’involucro convesso di <span class="math inline">\(S\)</span> in tempo
inferiore a <span class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<p>Se questo fosse il caso, prendendo la prima proiezione della lista
<span class="math inline">\((x_1, x_1^2), (x_2, x_2^2), ..., (x_n,
x_n^2)\)</span>. otterremo la lista <span class="math inline">\(x_1,
x_2, ..., x_n\)</span>. Dunque saremmo in grado di ordinare l’insieme
<span class="math inline">\(I\)</span> in tempo inferiore a <span
class="math inline">\(O(n \hspace{0.25em}log
\hspace{0.25em}n)\)</span>.</p>
<p>Questo è assurdo. <span class="math inline">\(\square\)</span></p>
<h1 id="involucro-convesso-naive">Involucro convesso naive</h1>
<h2 id="idea-dellalgoritmo-naive">Idea dell’algoritmo naive</h2>
<p>Per ogni coppia di punti <span class="math inline">\(\vec{u}, \vec{v}
\in S\)</span>, con <span class="math inline">\(\vec{u} \neq
\vec{v}\)</span>:</p>
<p>Consideriamo la retta <span class="math inline">\(r\)</span> passante
per <span class="math inline">\(\vec{u}\)</span> e <span
class="math inline">\(\vec{v}\)</span>.</p>
<p>Questa divide il piano <span class="math inline">\(\Pi\)</span> in
due semipiani, <span class="math inline">\(\Pi^+
\hspace{0.5em}\textrm{e} \hspace{0.5em}\Pi^-\)</span>.</p>
<p>Per ogni punto <span class="math inline">\(\vec{p} \in S\)</span> con
<span class="math inline">\(\vec{p} \neq \vec{u}
\hspace{0.5em}\textrm{e} \hspace{0.5em}\vec{p} \neq \vec{v}\)</span>
sono caudti esclusivamente in uno dei due semipiani, allora il segmento
con estremi <span class="math inline">\(\vec{u} \hspace{0.5em}\textrm{e}
\hspace{0.5em}\vec{v}\)</span> è un lato dell’involucro convesso.</p>
<h2 id="complessità-temporale">Complessità temporale</h2>
<ul>
<li>Iterare per ogni coppia di punti richiede tempo <span
class="math inline">\(O(n^2)\)</span>.</li>
<li>Iterare per ogni punto richiede tempo <span
class="math inline">\(O(n)\)</span>.</li>
<li>Combinando le due iterazione, vediamo come la complessità temporale
dell’algoritmo è <span class="math inline">\(O(n^3)\)</span>.</li>
</ul>
<h2
id="come-controllare-se-vecp-cade-in-pi-hspace0.5emtextrmo-hspace0.5empi-">Come
controllare se <span class="math inline">\(\vec{p}\)</span> cade in
<span class="math inline">\(\Pi^+ \hspace{0.5em}\textrm{o}
\hspace{0.5em}\Pi^-\)</span>?</h2>
<p>Supponiamo che il vettore <span class="math inline">\(\vec{v} -
\vec{u}\)</span> è un possibile vettore direzione della retta <span
class="math inline">\(r\)</span>.</p>
<p>Dato il vettore <span class="math inline">\(\vec{v} -
\vec{u}\)</span> troviamo un vettore <span
class="math inline">\(\vec{n}\)</span> perpendicolare ad esso.</p>
<p><span class="math inline">\(\vec{n}\)</span> è una possibile normale
della retta <span class="math inline">\(r\)</span>.</p>
<p>Dato un qualsiasi punto <span
class="math inline">\(\vec{p}\)</span>:</p>
<ol type="1">
<li>Prendiamo il vettore <span class="math inline">\(\vec{p} -
\vec{u}\)</span>.</li>
<li>Se <span class="math inline">\(\vec{n} \cdot (\vec{p} - \vec{u})
&gt; 0\)</span>, allora siamo in <span
class="math inline">\(\Pi^+\)</span>. <br/> Se <span
class="math inline">\(\vec{n} \cdot (\vec{p} - \vec{u}) &lt; 0\)</span>,
allora siamo in <span class="math inline">\(\Pi^-\)</span>.</li>
</ol>
<h2 id="come-trovare-un-vettore-perpendicolare-ad-un-altro">Come trovare
un vettore perpendicolare ad un altro?</h2>
<p>Consideriamo il vettore <span class="math inline">\(\vec{v}
\leftrightarrow \begin{bmatrix} v_x \\ v_y \end{bmatrix}\)</span>.</p>
<p>Un vettore <span class="math inline">\(\vec{u} \leftrightarrow
\begin{bmatrix} u_x \\ u_y \end{bmatrix}\)</span> è perpendicolare a
<span class="math inline">\(\vec{v}\)</span> se e solo se <span
class="math inline">\(\vec{u} \cdot \vec{v} = 0\)</span>.</p>
<p>Vogliamo determinare <span class="math inline">\(u_x
\hspace{0.5em}\textrm{e} \hspace{0.5em}u_y\)</span>, essendo a
conoscenza di <span class="math inline">\(v_x \hspace{0.5em}\textrm{e}
\hspace{0.5em}v_y\)</span>.</p>
<p>Sappiamo che <span class="math inline">\(\vec{u} \cdot \vec{v} =
0\)</span> se e solo se <span class="math inline">\(u_x v_x + u_y v_y =
0\)</span>.</p>
<p>Dunque <span class="math inline">\(u_x = - \dfrac{u_y v_y}{ v_x
}\)</span></p>
<p>Fissando <span class="math inline">\(u_y = v_x\)</span>, abbiamo che
<span class="math inline">\(u_x = - \dfrac{v_x v_y}{ v_x } =
-v_y\)</span></p>
</body>
</html>
